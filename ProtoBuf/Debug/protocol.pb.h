// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol.proto

#ifndef PROTOBUF_protocol_2eproto__INCLUDED
#define PROTOBUF_protocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protocol {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_protocol_2eproto();
void protobuf_AssignDesc_protocol_2eproto();
void protobuf_ShutdownFile_protocol_2eproto();

class Card;
class Card_CardTarget;

enum Card_CardType {
  Card_CardType_CT_UNIT = 0,
  Card_CardType_CT_ARCANE = 1
};
bool Card_CardType_IsValid(int value);
const Card_CardType Card_CardType_CardType_MIN = Card_CardType_CT_UNIT;
const Card_CardType Card_CardType_CardType_MAX = Card_CardType_CT_ARCANE;
const int Card_CardType_CardType_ARRAYSIZE = Card_CardType_CardType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Card_CardType_descriptor();
inline const ::std::string& Card_CardType_Name(Card_CardType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Card_CardType_descriptor(), value);
}
inline bool Card_CardType_Parse(
    const ::std::string& name, Card_CardType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Card_CardType>(
    Card_CardType_descriptor(), name, value);
}
enum Card_HandsIndex {
  Card_HandsIndex_HI_FIRST = 0,
  Card_HandsIndex_HI_SECOND = 1,
  Card_HandsIndex_HI_THIRD = 2,
  Card_HandsIndex_HI_FOURTH = 3
};
bool Card_HandsIndex_IsValid(int value);
const Card_HandsIndex Card_HandsIndex_HandsIndex_MIN = Card_HandsIndex_HI_FIRST;
const Card_HandsIndex Card_HandsIndex_HandsIndex_MAX = Card_HandsIndex_HI_FOURTH;
const int Card_HandsIndex_HandsIndex_ARRAYSIZE = Card_HandsIndex_HandsIndex_MAX + 1;

const ::google::protobuf::EnumDescriptor* Card_HandsIndex_descriptor();
inline const ::std::string& Card_HandsIndex_Name(Card_HandsIndex value) {
  return ::google::protobuf::internal::NameOfEnum(
    Card_HandsIndex_descriptor(), value);
}
inline bool Card_HandsIndex_Parse(
    const ::std::string& name, Card_HandsIndex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Card_HandsIndex>(
    Card_HandsIndex_descriptor(), name, value);
}
enum Card_FieldType {
  Card_FieldType_FT_MINE = 0,
  Card_FieldType_FT_OPPOSITE = 1
};
bool Card_FieldType_IsValid(int value);
const Card_FieldType Card_FieldType_FieldType_MIN = Card_FieldType_FT_MINE;
const Card_FieldType Card_FieldType_FieldType_MAX = Card_FieldType_FT_OPPOSITE;
const int Card_FieldType_FieldType_ARRAYSIZE = Card_FieldType_FieldType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Card_FieldType_descriptor();
inline const ::std::string& Card_FieldType_Name(Card_FieldType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Card_FieldType_descriptor(), value);
}
inline bool Card_FieldType_Parse(
    const ::std::string& name, Card_FieldType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Card_FieldType>(
    Card_FieldType_descriptor(), name, value);
}
enum Card_FieldFrontOrBack {
  Card_FieldFrontOrBack_FFOB_FRONT = 0,
  Card_FieldFrontOrBack_FFOB_BACK = 1
};
bool Card_FieldFrontOrBack_IsValid(int value);
const Card_FieldFrontOrBack Card_FieldFrontOrBack_FieldFrontOrBack_MIN = Card_FieldFrontOrBack_FFOB_FRONT;
const Card_FieldFrontOrBack Card_FieldFrontOrBack_FieldFrontOrBack_MAX = Card_FieldFrontOrBack_FFOB_BACK;
const int Card_FieldFrontOrBack_FieldFrontOrBack_ARRAYSIZE = Card_FieldFrontOrBack_FieldFrontOrBack_MAX + 1;

const ::google::protobuf::EnumDescriptor* Card_FieldFrontOrBack_descriptor();
inline const ::std::string& Card_FieldFrontOrBack_Name(Card_FieldFrontOrBack value) {
  return ::google::protobuf::internal::NameOfEnum(
    Card_FieldFrontOrBack_descriptor(), value);
}
inline bool Card_FieldFrontOrBack_Parse(
    const ::std::string& name, Card_FieldFrontOrBack* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Card_FieldFrontOrBack>(
    Card_FieldFrontOrBack_descriptor(), name, value);
}
enum Card_FieldIndex {
  Card_FieldIndex_FI_FIRST = 0,
  Card_FieldIndex_FI_SECOND = 1,
  Card_FieldIndex_FI_THIRD = 2
};
bool Card_FieldIndex_IsValid(int value);
const Card_FieldIndex Card_FieldIndex_FieldIndex_MIN = Card_FieldIndex_FI_FIRST;
const Card_FieldIndex Card_FieldIndex_FieldIndex_MAX = Card_FieldIndex_FI_THIRD;
const int Card_FieldIndex_FieldIndex_ARRAYSIZE = Card_FieldIndex_FieldIndex_MAX + 1;

const ::google::protobuf::EnumDescriptor* Card_FieldIndex_descriptor();
inline const ::std::string& Card_FieldIndex_Name(Card_FieldIndex value) {
  return ::google::protobuf::internal::NameOfEnum(
    Card_FieldIndex_descriptor(), value);
}
inline bool Card_FieldIndex_Parse(
    const ::std::string& name, Card_FieldIndex* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Card_FieldIndex>(
    Card_FieldIndex_descriptor(), name, value);
}
enum MessageType {
  PKT_CS_CARD = 0,
  PKT_MAX = 1
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = PKT_CS_CARD;
const MessageType MessageType_MAX = PKT_MAX;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Card_CardTarget : public ::google::protobuf::Message {
 public:
  Card_CardTarget();
  virtual ~Card_CardTarget();

  Card_CardTarget(const Card_CardTarget& from);

  inline Card_CardTarget& operator=(const Card_CardTarget& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Card_CardTarget& default_instance();

  void Swap(Card_CardTarget* other);

  // implements Message ----------------------------------------------

  inline Card_CardTarget* New() const { return New(NULL); }

  Card_CardTarget* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Card_CardTarget& from);
  void MergeFrom(const Card_CardTarget& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Card_CardTarget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.Card.FieldType fieldType = 1;
  inline bool has_fieldtype() const;
  inline void clear_fieldtype();
  static const int kFieldTypeFieldNumber = 1;
  inline ::protocol::Card_FieldType fieldtype() const;
  inline void set_fieldtype(::protocol::Card_FieldType value);

  // required .protocol.Card.FieldFrontOrBack fieldFrontOrBack = 2;
  inline bool has_fieldfrontorback() const;
  inline void clear_fieldfrontorback();
  static const int kFieldFrontOrBackFieldNumber = 2;
  inline ::protocol::Card_FieldFrontOrBack fieldfrontorback() const;
  inline void set_fieldfrontorback(::protocol::Card_FieldFrontOrBack value);

  // required .protocol.Card.FieldIndex fieldIndex = 3;
  inline bool has_fieldindex() const;
  inline void clear_fieldindex();
  static const int kFieldIndexFieldNumber = 3;
  inline ::protocol::Card_FieldIndex fieldindex() const;
  inline void set_fieldindex(::protocol::Card_FieldIndex value);

  // @@protoc_insertion_point(class_scope:protocol.Card.CardTarget)
 private:
  inline void set_has_fieldtype();
  inline void clear_has_fieldtype();
  inline void set_has_fieldfrontorback();
  inline void clear_has_fieldfrontorback();
  inline void set_has_fieldindex();
  inline void clear_has_fieldindex();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int fieldtype_;
  int fieldfrontorback_;
  int fieldindex_;
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static Card_CardTarget* default_instance_;
};
// -------------------------------------------------------------------

class Card : public ::google::protobuf::Message {
 public:
  Card();
  virtual ~Card();

  Card(const Card& from);

  inline Card& operator=(const Card& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Card& default_instance();

  void Swap(Card* other);

  // implements Message ----------------------------------------------

  inline Card* New() const { return New(NULL); }

  Card* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Card& from);
  void MergeFrom(const Card& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Card* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Card_CardTarget CardTarget;

  typedef Card_CardType CardType;
  static const CardType CT_UNIT = Card_CardType_CT_UNIT;
  static const CardType CT_ARCANE = Card_CardType_CT_ARCANE;
  static inline bool CardType_IsValid(int value) {
    return Card_CardType_IsValid(value);
  }
  static const CardType CardType_MIN =
    Card_CardType_CardType_MIN;
  static const CardType CardType_MAX =
    Card_CardType_CardType_MAX;
  static const int CardType_ARRAYSIZE =
    Card_CardType_CardType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CardType_descriptor() {
    return Card_CardType_descriptor();
  }
  static inline const ::std::string& CardType_Name(CardType value) {
    return Card_CardType_Name(value);
  }
  static inline bool CardType_Parse(const ::std::string& name,
      CardType* value) {
    return Card_CardType_Parse(name, value);
  }

  typedef Card_HandsIndex HandsIndex;
  static const HandsIndex HI_FIRST = Card_HandsIndex_HI_FIRST;
  static const HandsIndex HI_SECOND = Card_HandsIndex_HI_SECOND;
  static const HandsIndex HI_THIRD = Card_HandsIndex_HI_THIRD;
  static const HandsIndex HI_FOURTH = Card_HandsIndex_HI_FOURTH;
  static inline bool HandsIndex_IsValid(int value) {
    return Card_HandsIndex_IsValid(value);
  }
  static const HandsIndex HandsIndex_MIN =
    Card_HandsIndex_HandsIndex_MIN;
  static const HandsIndex HandsIndex_MAX =
    Card_HandsIndex_HandsIndex_MAX;
  static const int HandsIndex_ARRAYSIZE =
    Card_HandsIndex_HandsIndex_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HandsIndex_descriptor() {
    return Card_HandsIndex_descriptor();
  }
  static inline const ::std::string& HandsIndex_Name(HandsIndex value) {
    return Card_HandsIndex_Name(value);
  }
  static inline bool HandsIndex_Parse(const ::std::string& name,
      HandsIndex* value) {
    return Card_HandsIndex_Parse(name, value);
  }

  typedef Card_FieldType FieldType;
  static const FieldType FT_MINE = Card_FieldType_FT_MINE;
  static const FieldType FT_OPPOSITE = Card_FieldType_FT_OPPOSITE;
  static inline bool FieldType_IsValid(int value) {
    return Card_FieldType_IsValid(value);
  }
  static const FieldType FieldType_MIN =
    Card_FieldType_FieldType_MIN;
  static const FieldType FieldType_MAX =
    Card_FieldType_FieldType_MAX;
  static const int FieldType_ARRAYSIZE =
    Card_FieldType_FieldType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FieldType_descriptor() {
    return Card_FieldType_descriptor();
  }
  static inline const ::std::string& FieldType_Name(FieldType value) {
    return Card_FieldType_Name(value);
  }
  static inline bool FieldType_Parse(const ::std::string& name,
      FieldType* value) {
    return Card_FieldType_Parse(name, value);
  }

  typedef Card_FieldFrontOrBack FieldFrontOrBack;
  static const FieldFrontOrBack FFOB_FRONT = Card_FieldFrontOrBack_FFOB_FRONT;
  static const FieldFrontOrBack FFOB_BACK = Card_FieldFrontOrBack_FFOB_BACK;
  static inline bool FieldFrontOrBack_IsValid(int value) {
    return Card_FieldFrontOrBack_IsValid(value);
  }
  static const FieldFrontOrBack FieldFrontOrBack_MIN =
    Card_FieldFrontOrBack_FieldFrontOrBack_MIN;
  static const FieldFrontOrBack FieldFrontOrBack_MAX =
    Card_FieldFrontOrBack_FieldFrontOrBack_MAX;
  static const int FieldFrontOrBack_ARRAYSIZE =
    Card_FieldFrontOrBack_FieldFrontOrBack_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FieldFrontOrBack_descriptor() {
    return Card_FieldFrontOrBack_descriptor();
  }
  static inline const ::std::string& FieldFrontOrBack_Name(FieldFrontOrBack value) {
    return Card_FieldFrontOrBack_Name(value);
  }
  static inline bool FieldFrontOrBack_Parse(const ::std::string& name,
      FieldFrontOrBack* value) {
    return Card_FieldFrontOrBack_Parse(name, value);
  }

  typedef Card_FieldIndex FieldIndex;
  static const FieldIndex FI_FIRST = Card_FieldIndex_FI_FIRST;
  static const FieldIndex FI_SECOND = Card_FieldIndex_FI_SECOND;
  static const FieldIndex FI_THIRD = Card_FieldIndex_FI_THIRD;
  static inline bool FieldIndex_IsValid(int value) {
    return Card_FieldIndex_IsValid(value);
  }
  static const FieldIndex FieldIndex_MIN =
    Card_FieldIndex_FieldIndex_MIN;
  static const FieldIndex FieldIndex_MAX =
    Card_FieldIndex_FieldIndex_MAX;
  static const int FieldIndex_ARRAYSIZE =
    Card_FieldIndex_FieldIndex_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FieldIndex_descriptor() {
    return Card_FieldIndex_descriptor();
  }
  static inline const ::std::string& FieldIndex_Name(FieldIndex value) {
    return Card_FieldIndex_Name(value);
  }
  static inline bool FieldIndex_Parse(const ::std::string& name,
      FieldIndex* value) {
    return Card_FieldIndex_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required fixed32 playerID = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIDFieldNumber = 1;
  inline ::google::protobuf::uint32 playerid() const;
  inline void set_playerid(::google::protobuf::uint32 value);

  // required fixed32 gameID = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIDFieldNumber = 2;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // required .protocol.Card.CardType cardType = 3;
  inline bool has_cardtype() const;
  inline void clear_cardtype();
  static const int kCardTypeFieldNumber = 3;
  inline ::protocol::Card_CardType cardtype() const;
  inline void set_cardtype(::protocol::Card_CardType value);

  // optional .protocol.Card.HandsIndex handsIndex = 4;
  inline bool has_handsindex() const;
  inline void clear_handsindex();
  static const int kHandsIndexFieldNumber = 4;
  inline ::protocol::Card_HandsIndex handsindex() const;
  inline void set_handsindex(::protocol::Card_HandsIndex value);

  // repeated .protocol.Card.CardTarget cardTarget = 5;
  inline int cardtarget_size() const;
  inline void clear_cardtarget();
  static const int kCardTargetFieldNumber = 5;
  inline const ::protocol::Card_CardTarget& cardtarget(int index) const;
  inline ::protocol::Card_CardTarget* mutable_cardtarget(int index);
  inline ::protocol::Card_CardTarget* add_cardtarget();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Card_CardTarget >&
      cardtarget() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Card_CardTarget >*
      mutable_cardtarget();

  // @@protoc_insertion_point(class_scope:protocol.Card)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_cardtype();
  inline void clear_has_cardtype();
  inline void set_has_handsindex();
  inline void clear_has_handsindex();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 playerid_;
  ::google::protobuf::uint32 gameid_;
  int cardtype_;
  int handsindex_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Card_CardTarget > cardtarget_;
  friend void  protobuf_AddDesc_protocol_2eproto();
  friend void protobuf_AssignDesc_protocol_2eproto();
  friend void protobuf_ShutdownFile_protocol_2eproto();

  void InitAsDefaultInstance();
  static Card* default_instance_;
};
// ===================================================================


// ===================================================================

// Card_CardTarget

// required .protocol.Card.FieldType fieldType = 1;
inline bool Card_CardTarget::has_fieldtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Card_CardTarget::set_has_fieldtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Card_CardTarget::clear_has_fieldtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Card_CardTarget::clear_fieldtype() {
  fieldtype_ = 0;
  clear_has_fieldtype();
}
inline ::protocol::Card_FieldType Card_CardTarget::fieldtype() const {
  // @@protoc_insertion_point(field_get:protocol.Card.CardTarget.fieldType)
  return static_cast< ::protocol::Card_FieldType >(fieldtype_);
}
inline void Card_CardTarget::set_fieldtype(::protocol::Card_FieldType value) {
  assert(::protocol::Card_FieldType_IsValid(value));
  set_has_fieldtype();
  fieldtype_ = value;
  // @@protoc_insertion_point(field_set:protocol.Card.CardTarget.fieldType)
}

// required .protocol.Card.FieldFrontOrBack fieldFrontOrBack = 2;
inline bool Card_CardTarget::has_fieldfrontorback() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Card_CardTarget::set_has_fieldfrontorback() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Card_CardTarget::clear_has_fieldfrontorback() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Card_CardTarget::clear_fieldfrontorback() {
  fieldfrontorback_ = 0;
  clear_has_fieldfrontorback();
}
inline ::protocol::Card_FieldFrontOrBack Card_CardTarget::fieldfrontorback() const {
  // @@protoc_insertion_point(field_get:protocol.Card.CardTarget.fieldFrontOrBack)
  return static_cast< ::protocol::Card_FieldFrontOrBack >(fieldfrontorback_);
}
inline void Card_CardTarget::set_fieldfrontorback(::protocol::Card_FieldFrontOrBack value) {
  assert(::protocol::Card_FieldFrontOrBack_IsValid(value));
  set_has_fieldfrontorback();
  fieldfrontorback_ = value;
  // @@protoc_insertion_point(field_set:protocol.Card.CardTarget.fieldFrontOrBack)
}

// required .protocol.Card.FieldIndex fieldIndex = 3;
inline bool Card_CardTarget::has_fieldindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Card_CardTarget::set_has_fieldindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Card_CardTarget::clear_has_fieldindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Card_CardTarget::clear_fieldindex() {
  fieldindex_ = 0;
  clear_has_fieldindex();
}
inline ::protocol::Card_FieldIndex Card_CardTarget::fieldindex() const {
  // @@protoc_insertion_point(field_get:protocol.Card.CardTarget.fieldIndex)
  return static_cast< ::protocol::Card_FieldIndex >(fieldindex_);
}
inline void Card_CardTarget::set_fieldindex(::protocol::Card_FieldIndex value) {
  assert(::protocol::Card_FieldIndex_IsValid(value));
  set_has_fieldindex();
  fieldindex_ = value;
  // @@protoc_insertion_point(field_set:protocol.Card.CardTarget.fieldIndex)
}

// -------------------------------------------------------------------

// Card

// required fixed32 playerID = 1;
inline bool Card::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Card::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Card::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Card::clear_playerid() {
  playerid_ = 0u;
  clear_has_playerid();
}
inline ::google::protobuf::uint32 Card::playerid() const {
  // @@protoc_insertion_point(field_get:protocol.Card.playerID)
  return playerid_;
}
inline void Card::set_playerid(::google::protobuf::uint32 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:protocol.Card.playerID)
}

// required fixed32 gameID = 2;
inline bool Card::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Card::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Card::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Card::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 Card::gameid() const {
  // @@protoc_insertion_point(field_get:protocol.Card.gameID)
  return gameid_;
}
inline void Card::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
  // @@protoc_insertion_point(field_set:protocol.Card.gameID)
}

// required .protocol.Card.CardType cardType = 3;
inline bool Card::has_cardtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Card::set_has_cardtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Card::clear_has_cardtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Card::clear_cardtype() {
  cardtype_ = 0;
  clear_has_cardtype();
}
inline ::protocol::Card_CardType Card::cardtype() const {
  // @@protoc_insertion_point(field_get:protocol.Card.cardType)
  return static_cast< ::protocol::Card_CardType >(cardtype_);
}
inline void Card::set_cardtype(::protocol::Card_CardType value) {
  assert(::protocol::Card_CardType_IsValid(value));
  set_has_cardtype();
  cardtype_ = value;
  // @@protoc_insertion_point(field_set:protocol.Card.cardType)
}

// optional .protocol.Card.HandsIndex handsIndex = 4;
inline bool Card::has_handsindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Card::set_has_handsindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Card::clear_has_handsindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Card::clear_handsindex() {
  handsindex_ = 0;
  clear_has_handsindex();
}
inline ::protocol::Card_HandsIndex Card::handsindex() const {
  // @@protoc_insertion_point(field_get:protocol.Card.handsIndex)
  return static_cast< ::protocol::Card_HandsIndex >(handsindex_);
}
inline void Card::set_handsindex(::protocol::Card_HandsIndex value) {
  assert(::protocol::Card_HandsIndex_IsValid(value));
  set_has_handsindex();
  handsindex_ = value;
  // @@protoc_insertion_point(field_set:protocol.Card.handsIndex)
}

// repeated .protocol.Card.CardTarget cardTarget = 5;
inline int Card::cardtarget_size() const {
  return cardtarget_.size();
}
inline void Card::clear_cardtarget() {
  cardtarget_.Clear();
}
inline const ::protocol::Card_CardTarget& Card::cardtarget(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Card.cardTarget)
  return cardtarget_.Get(index);
}
inline ::protocol::Card_CardTarget* Card::mutable_cardtarget(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Card.cardTarget)
  return cardtarget_.Mutable(index);
}
inline ::protocol::Card_CardTarget* Card::add_cardtarget() {
  // @@protoc_insertion_point(field_add:protocol.Card.cardTarget)
  return cardtarget_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Card_CardTarget >&
Card::cardtarget() const {
  // @@protoc_insertion_point(field_list:protocol.Card.cardTarget)
  return cardtarget_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Card_CardTarget >*
Card::mutable_cardtarget() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Card.cardTarget)
  return &cardtarget_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::Card_CardType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Card_CardType>() {
  return ::protocol::Card_CardType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Card_HandsIndex> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Card_HandsIndex>() {
  return ::protocol::Card_HandsIndex_descriptor();
}
template <> struct is_proto_enum< ::protocol::Card_FieldType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Card_FieldType>() {
  return ::protocol::Card_FieldType_descriptor();
}
template <> struct is_proto_enum< ::protocol::Card_FieldFrontOrBack> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Card_FieldFrontOrBack>() {
  return ::protocol::Card_FieldFrontOrBack_descriptor();
}
template <> struct is_proto_enum< ::protocol::Card_FieldIndex> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Card_FieldIndex>() {
  return ::protocol::Card_FieldIndex_descriptor();
}
template <> struct is_proto_enum< ::protocol::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::MessageType>() {
  return ::protocol::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_2eproto__INCLUDED
